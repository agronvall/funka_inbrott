<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <title>Excel → Dynamisk Protokoll</title>

  <!-- Viewport for responsive design -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Bootstrap 5 CSS from CDN (no SRI) -->
  <link 
    rel="stylesheet" 
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    crossorigin="anonymous"
  />

  <!-- SheetJS for parsing Excel in-browser -->
  <script 
    src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js">
  </script>

  <!-- jsPDF + AutoTable for PDF generation -->
  <script
    src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js">
  </script>
  <script
    src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.5.25/dist/jspdf.plugin.autotable.js">
  </script>

  <style>
    body {
      background-color: #f1f3f5; /* A subtle grey background */
    }
    .navbar {
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    /* Sticky table headers */
    .table thead th {
      position: sticky;
      top: 0;
      background-color: #495057; /* Darker grey */
      color: #fff;
      z-index: 2;
    }
    /* Card-like sections with a slight shadow */
    .section-card {
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    /* The final text report preview box */
    #reportOutput {
      white-space: pre-wrap;
      border: 1px solid #ddd;
      background: #fafafa;
      border-radius: 4px;
      padding: 1rem;
      display: none; /* hidden until we generate it */
      max-height: 350px;
      overflow-y: auto;
      margin-top: 1rem;
    }
  </style>
</head>
<body>

<!-- 1. Dark Navbar -->
<nav class="navbar navbar-dark bg-dark mb-4">
  <div class="container">
    <span class="navbar-brand mb-0 h1">Dynamisk Protokoll</span>
  </div>
</nav>

<!-- 2. Main container -->
<div class="container">
  <!-- Step 1: File Input -->
  <div class="section-card">
    <h4 class="mb-3">1. Välj Excel‐fil</h4>
    <p class="text-muted mb-2">
      Filen läses endast lokalt i din webbläsare; ingen data skickas till servern.
    </p>
    <input 
      type="file" 
      id="excelFile" 
      accept=".xlsx,.xls,.csv"
      class="form-control"
    />
  </div>

  <!-- Step 2: Header Fields -->
  <div id="headerFields" class="section-card">
    <h4 class="mb-3">2. Headerfält (från Excel eller manuellt)</h4>
    <div class="row g-3">
      <div class="col-md-4">
        <label class="form-label">Anläggning</label>
        <input 
          type="text" 
          id="inpAnlaggning"
          class="form-control"
          placeholder="(Tom)"
        />
      </div>
      <div class="col-md-4">
        <label class="form-label">Anläggningsnr</label>
        <input 
          type="text" 
          id="inpAnlaggNr"
          class="form-control"
          placeholder="(Tom)"
        />
      </div>
      <div class="col-md-4">
        <label class="form-label">Adress</label>
        <input 
          type="text" 
          id="inpAdress"
          class="form-control"
          placeholder="(Tom)"
        />
      </div>
      <div class="col-md-4">
        <label class="form-label">Behörig ingenjör</label>
        <input 
          type="text" 
          id="inpIngenjor"
          class="form-control"
          placeholder="(Tom)"
        />
      </div>
      <div class="col-md-4">
        <label class="form-label">Ansvarig tekniker</label>
        <input 
          type="text" 
          id="inpTekniker"
          class="form-control"
          placeholder="(Tom)"
        />
      </div>
      <div class="col-md-4">
        <label class="form-label">Datum</label>
        <input 
          type="text" 
          id="inpDatum"
          class="form-control"
          placeholder="(Tom)"
        />
      </div>
    </div>
  </div>

  <!-- Step 3: Table Section -->
  <div class="section-card">
    <h4 class="mb-3">3. Tabell</h4>
    <p class="text-muted">
      Raderna nedan hämtas från Excel (sheet "Service" eller första arket). 
      Du kan redigera celler och lägga till nya rader.
    </p>
    <div class="table-responsive" id="tableContainer"></div>

    <!-- Action Buttons -->
    <div class="mt-3">
      <button id="addRowBtn" class="btn btn-outline-primary me-2" style="display:none;">
        Lägg till ny rad
      </button>
      <button id="generateReportBtn" class="btn btn-primary" style="display:none;">
        Generera rapport
      </button>
      <button id="downloadPdfBtn" class="btn btn-success" style="display:none;">
        Ladda ner PDF
      </button>
    </div>
  </div>

  <!-- Step 4: Output -->
  <div class="section-card">
    <h4 class="mb-3">4. Rapport</h4>
    <div id="reportOutput"></div>
  </div>

</div>

<!-- Footer -->
<footer class="text-center text-muted py-3">
  <small>© 2025 Din Firma – Allt sker lokalt i webbläsaren</small>
</footer>

<!-- Bootstrap 5 JS (no SRI) -->
<script 
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
  crossorigin="anonymous">
</script>

<script>
  /*
    1) We treat certain columns as checkboxes instead of text.
    2) We also parse the top ~20 rows for known labels (e.g. "Anläggning:") 
       to fill the "headerFields".
  */

  // Columns that become checkboxes
  const checkboxColumns = ["Ritning", "Provad Sign", "Åtgärdad Sign"];

  // Mapping label text -> our headerInfo keys
  const labelMap = {
    "anläggning:":         "anlaggning",
    "anläggningsnr:":      "anlaggningsnr",
    "anläggningsadress:":  "adress",
    "behörig ingenjör:":   "behorigIngenjor",
    "ansvarig tekniker:":  "ansvarigTekniker",
    "datum:":              "datum"
  };

  // We'll store the user data in these
  let headerInfo = {
    anlaggning:       "",
    anlaggningsnr:    "",
    adress:           "",
    behorigIngenjor:  "",
    ansvarigTekniker: "",
    datum:            ""
  };
  let tableHeaders = [];
  let tableRows = [];

  // Hook up file input
  document.getElementById('excelFile').addEventListener('change', handleFile);

  function handleFile(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = evt => {
      const data = evt.target.result;

      // Parse with XLSX
      const workbook = XLSX.read(data, { type: 'binary' });

      // "Service" sheet or fallback to the first sheet
      const sheetName = workbook.SheetNames.includes("Service")
                        ? "Service"
                        : workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      if (!worksheet) {
        alert("Kunde inte hitta ett giltigt kalkylblad i filen.");
        return;
      }

      // Convert to array-of-arrays
      const sheetData = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        blankrows: false
      });
      if (!sheetData || sheetData.length === 0) {
        alert("Inga data hittades i arket.");
        return;
      }

      // Extract known fields from top portion
      extractHeaderFields(sheetData);

      // Find row with "UNR." in col 0 => table header
      let headerRowIndex = sheetData.findIndex(row => {
        return (
          typeof row[0] === 'string' &&
          row[0].trim().toLowerCase() === "unr."
        );
      });
      if (headerRowIndex === -1) headerRowIndex = 0; // fallback

      // The row at headerRowIndex => table headers
      tableHeaders = (sheetData[headerRowIndex] || []).map(h => (h || "").toString().trim());

      // Subsequent rows => data, until blank row
      tableRows = [];
      for (let r = headerRowIndex + 1; r < sheetData.length; r++) {
        const rowArr = sheetData[r] || [];
        const isEmpty = rowArr.every(cell => !cell || cell.toString().trim() === "");
        if (isEmpty) break;
        tableRows.push(rowArr);
      }

      // Build UI
      fillHeaderFields();
      buildTable();

      // Show action buttons
      document.getElementById('addRowBtn').style.display = 'inline-block';
      document.getElementById('generateReportBtn').style.display = 'inline-block';
      document.getElementById('downloadPdfBtn').style.display = 'inline-block';

      // Hook up events
      document.getElementById('addRowBtn').onclick = addRow;
      document.getElementById('generateReportBtn').onclick = generateReport;
      document.getElementById('downloadPdfBtn').onclick = downloadPdf;
    };
    reader.readAsBinaryString(file);
  }

  function extractHeaderFields(sheetData) {
    // We look up to 20 rows x 10 cols for known labels
    const maxRows = Math.min(sheetData.length, 20);
    const maxCols = 10;
    for (let r = 0; r < maxRows; r++) {
      const row = sheetData[r] || [];
      for (let c = 0; c < Math.min(row.length, maxCols); c++) {
        const cellVal = (row[c] || "").toString().trim().toLowerCase();
        if (cellVal in labelMap) {
          let foundVal = "";
          // Next column same row
          if (row[c+1]) {
            foundVal = row[c+1].toString().trim();
          }
          // If still empty, check the next row, same column
          if (!foundVal && sheetData[r+1] && sheetData[r+1][c]) {
            foundVal = sheetData[r+1][c].toString().trim();
          }
          headerInfo[labelMap[cellVal]] = foundVal;
        }
      }
    }
  }

  function fillHeaderFields() {
    document.getElementById('inpAnlaggning').value = headerInfo.anlaggning;
    document.getElementById('inpAnlaggNr').value   = headerInfo.anlaggningsnr;
    document.getElementById('inpAdress').value     = headerInfo.adress;
    document.getElementById('inpIngenjor').value   = headerInfo.behorigIngenjor;
    document.getElementById('inpTekniker').value   = headerInfo.ansvarigTekniker;
    document.getElementById('inpDatum').value      = headerInfo.datum;
  }

  function buildTable() {
    const container = document.getElementById('tableContainer');
    container.innerHTML = ""; // clear old

    if (!tableHeaders.length) {
      container.innerHTML = '<p class="text-danger">Inga kolumnrubriker hittades.</p>';
      return;
    }

    // Create a table
    const table = document.createElement('table');
    table.className = 'table table-striped table-hover align-middle';

    // THEAD
    const thead = document.createElement('thead');
    const thr = document.createElement('tr');
    tableHeaders.forEach(hdr => {
      const th = document.createElement('th');
      th.textContent = hdr;
      thr.appendChild(th);
    });
    thead.appendChild(thr);
    table.appendChild(thead);

    // TBODY
    const tbody = document.createElement('tbody');
    tableRows.forEach(rowArr => {
      const tr = document.createElement('tr');
      for (let c = 0; c < tableHeaders.length; c++) {
        tr.appendChild(createCell(tableHeaders[c], rowArr[c]));
      }
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    container.appendChild(table);
  }

  function createCell(header, val) {
    const td = document.createElement('td');
    // Check if it's a checkbox column
    if (checkboxColumns.some(col => col.toLowerCase() === header.toLowerCase())) {
      const input = document.createElement('input');
      input.type = 'checkbox';
      // If the existing cell is "X", "true", etc., check it
      if (isChecked(val)) input.checked = true;
      td.appendChild(input);
    } else {
      // text input
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'form-control form-control-sm';
      input.value = val ? val.toString() : '';
      td.appendChild(input);
    }
    return td;
  }

  function isChecked(val) {
    if (!val) return false;
    const s = val.toString().trim().toLowerCase();
    return ['1','true','yes','x','checked'].includes(s);
  }

  function addRow() {
    // sync any current edits
    syncTableFromDOM();
    // add a blank row
    const blankRow = new Array(tableHeaders.length).fill("");
    tableRows.push(blankRow);
    buildTable();
  }

  function syncTableFromDOM() {
    const table = document.querySelector('#tableContainer table');
    if (!table) return;
    const rows = table.querySelectorAll('tbody tr');

    const updatedData = [];
    rows.forEach(tr => {
      const cells = tr.querySelectorAll('td');
      const rowArr = [];
      cells.forEach(td => {
        const input = td.querySelector('input');
        if (input && input.type === 'checkbox') {
          rowArr.push(input.checked ? 'X' : '');
        } else if (input && input.type === 'text') {
          rowArr.push(input.value.trim());
        } else {
          rowArr.push(''); // fallback
        }
      });
      updatedData.push(rowArr);
    });
    tableRows = updatedData;
  }

  function generateReport() {
    // Update header fields from the user input
    headerInfo.anlaggning       = document.getElementById('inpAnlaggning').value.trim();
    headerInfo.anlaggningsnr    = document.getElementById('inpAnlaggNr').value.trim();
    headerInfo.adress           = document.getElementById('inpAdress').value.trim();
    headerInfo.behorigIngenjor  = document.getElementById('inpIngenjor').value.trim();
    headerInfo.ansvarigTekniker = document.getElementById('inpTekniker').value.trim();
    headerInfo.datum            = document.getElementById('inpDatum').value.trim();

    // Sync table
    syncTableFromDOM();

    // Build text
    let txt = "=== UNR_Sektionsförteckning provningsprotokoll Service ===\n\n";
    txt += `Anläggning:       ${headerInfo.anlaggning}\n`;
    txt += `Anläggningsnr:    ${headerInfo.anlaggningsnr}\n`;
    txt += `Adress:           ${headerInfo.adress}\n`;
    txt += `Behörig ingenjör: ${headerInfo.behorigIngenjor}\n`;
    txt += `Ansvarig tekniker:${headerInfo.ansvarigTekniker}\n`;
    txt += `Datum:            ${headerInfo.datum}\n`;
    txt += "\n=== Tabellinnehåll ===\n";

    tableRows.forEach((row, idx) => {
      txt += `\nRad #${idx + 1}:\n`;
      for (let c = 0; c < tableHeaders.length; c++) {
        const colName = tableHeaders[c] || `Kolumn ${c+1}`;
        const val = row[c] || "";
        txt += `  ${colName}: ${val}\n`;
      }
    });

    const out = document.getElementById('reportOutput');
    out.textContent = txt;
    out.style.display = 'block';
  }

  async function downloadPdf() {
    // We do basically the same data collection as generateReport, but format it into a PDF.
    generateReport(); // to ensure we have the latest data & text

    // Import jsPDF from the UMD bundle
    const { jsPDF } = window.jspdf;

    // Create a new PDF
    const doc = new jsPDF({ unit: "pt", format: "a4" });

    // 1) Add a title
    doc.setFont("helvetica", "bold");
    doc.setFontSize(14);
    doc.text("UNR_Sektionsförteckning provningsprotokoll Service", 40, 40);

    // 2) Display the header fields
    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);

    let yPos = 60;
    doc.text(`Anläggning:       ${headerInfo.anlaggning}`, 40, yPos);
    yPos += 15;
    doc.text(`Anläggningsnr:    ${headerInfo.anlaggningsnr}`, 40, yPos);
    yPos += 15;
    doc.text(`Adress:           ${headerInfo.adress}`, 40, yPos);
    yPos += 15;
    doc.text(`Behörig ingenjör: ${headerInfo.behorigIngenjor}`, 40, yPos);
    yPos += 15;
    doc.text(`Ansvarig tekniker:${headerInfo.ansvarigTekniker}`, 40, yPos);
    yPos += 15;
    doc.text(`Datum:            ${headerInfo.datum}`, 40, yPos);
    yPos += 25;

    // 3) Build table data for jsPDF-AutoTable
    //    We'll convert tableRows into an array-of-arrays, just like we have,
    //    but we also want the tableHeaders as columns. 
    const columns = tableHeaders.map(header => ({ header, dataKey: header }));
    // Convert each row from an array => an object with keys matching our headers
    const tableData = tableRows.map(rowArr => {
      const rowObj = {};
      rowArr.forEach((cellVal, idx) => {
        const colName = tableHeaders[idx] || `col${idx}`;
        rowObj[colName] = cellVal;
      });
      return rowObj;
    });

    doc.autoTable({
      startY: yPos,
      head: [ tableHeaders ],    // or columns
      body: tableRows,           // simpler approach if each row is an array
      margin: { left: 40, right: 40 },
      styles: { font: 'helvetica', fontSize: 10 },
      headStyles: { fillColor: [73,80,87] }, // #495057
    });

    // 4) Save the PDF
    doc.save("protokoll.pdf");
  }
</script>
</body>
</html>
